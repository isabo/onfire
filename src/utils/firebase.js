/**
 * Promisify Firebase methods.
 */


goog.provide('onfire.utils.firebase');
goog.provide('onfire.utils.firebase.EventType');

goog.require('onfire.utils.promise');
goog.require('onfire.utils.detection');


if (onfire.utils.detection.IS_NODEJS) {
    /**
     * @private
     */
    onfire.utils.Firebase_ = /** @type {!function(new:Firebase, string)} */(require('firebase'));
} else {
    onfire.utils.Firebase_ = Firebase;
}


/**
 * Create a Firebase ref in a way that won't generate Closure Compiler errors.
 *
 * @param {string} path
 * @return {!Firebase}
 */
onfire.utils.firebase.newFirebase = function(path) {

    if (onfire.utils.detection.IS_NODEJS) {
        var fb = onfire.utils.Firebase_;
        return new fb(path);
    } else {
        return new Firebase(path);
    }
};


/**
 * Push a value under a Firebase reference.
 *
 * @param {!Firebase} ref
 * @param {Firebase.Value=} opt_value
 * @return {!Promise<!Firebase,!Error>|!goog.Promise<!Firebase,!Error>}
 */
onfire.utils.firebase.push = function(ref, opt_value) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        if (goog.isDef(opt_value)) {
            var childRef = ref.push(opt_value, function(/** Error */err) {
                !err ? resolve(childRef) : reject(err);
            });
        } else {
            // Nothing to put there - just return the autogenerated ID.
            resolve(ref.push());
        }
    });
};


/**
 * Set the value at a Firebase reference.
 *
 * @param {!Firebase} ref
 * @param {Firebase.Value} value
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>}
 */
onfire.utils.firebase.set = function(ref, value) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.set(value, function(/** Error */err) {
            !err ? resolve() : reject(err);
        });
    });
};


/**
 * Set the value at a Firebase reference.
 *
 * @param {!Firebase} ref
 * @param {!Object<string,Firebase.Value>} values
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>}
 */
onfire.utils.firebase.update = function(ref, values) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.update(values, function(/** Error */err) {
            !err ? resolve() : reject(err);
        });
    });
};


/**
 * Performs an atomic transaction at a Firebase reference.
 *
 * @param {!Firebase} ref
 * @param {function(Firebase.Value):(Firebase.Value|undefined)} updateFn
 * @return
    {
        !Promise<!{{isCommitted:boolean,snapshot:Firebase.DataSnapshot}},!Error>
        |
        !goog.Promise<!{{isCommitted:boolean,snapshot:Firebase.DataSnapshot}},!Error>
    }
 */
onfire.utils.firebase.transaction = function(ref, updateFn) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.transaction(updateFn,
            function(/**Error*/err, /**boolean*/isCommitted, /**!Firebase.DataSnapshot*/snapshot) {
                !err ? resolve({'isCommitted': isCommitted, 'snapshot': snapshot}) : reject(err);
            }, false);
    });
};


/**
 * Set the value at a Firebase reference.
 *
 * @param {!Firebase} ref
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>}
 */
onfire.utils.firebase.remove = function(ref) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.remove(function(/** Error */err) {
            !err ? resolve() : reject(err);
        });
    });
};


/**
 * Wait for the first event of a specified type at a Firebase reference.
 *
 * @param {!Firebase} ref
 * @param {onfire.utils.firebase.EventType} eventType
 * @return {!Promise<!Firebase.DataSnapshot,!Error>|!goog.Promise<!Firebase.DataSnapshot,!Error>}
 */
onfire.utils.firebase.once = function(ref, eventType) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.once(eventType, function(/** !Firebase.DataSnapshot */snapshot) {
            resolve(snapshot);
        }, function(err) {
            reject(err);
        });
    });
};


/**
 * Firebase.authWithCustomToken() wrapped in a promise.
 *
 * @param {string} authToken
 * @param {!Object=} opt_options
 * @return
    {
        !Promise<!Firebase.AuthCallbackData,!Error>
        |
        !goog.Promise<!Firebase.AuthCallbackData,!Error>
    } A promise which resolves to the authData, or is rejected with an error.
 */
onfire.utils.firebase.authWithCustomToken = function(ref, authToken, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authWithCustomToken(authToken,
            function(/** Firebase.Error */err, /** Firebase.AuthCallbackData */authData){
                !err ? resolve(authData) : reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.authAnonymously() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!Object=} opt_options
 * @return
    {
     !Promise<!Firebase.AuthCallbackData,!Error>
     |
     !goog.Promise<!Firebase.AuthCallbackData,!Error>
    } A promise which resolves to the authData, or is rejected with an error.
 */
onfire.utils.firebase.authAnonymously = function(ref, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authAnonymously(
            function(/** Firebase.Error */err, /** Firebase.AuthCallbackData */authData){
                !err ? resolve(authData) : reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.authWithPassword() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!Firebase.AuthPasswordCredentials} credentials
 * @param {!Object=} opt_options
 * @return
    {
     !Promise<!Firebase.AuthCallbackData,!Error>
     |
     !goog.Promise<!Firebase.AuthCallbackData,!Error>
    } A promise which resolves to the authData, or is rejected with an error.
 */
onfire.utils.firebase.authWithPassword = function(ref, credentials, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authWithPassword(credentials,
            function(/** Firebase.Error */err, /** Firebase.AuthCallbackData */authData){
                !err ? resolve(authData) : reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.authWithOAuthPopup() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {string} provider
 * @param {!Object=} opt_options
 * @return
    {
     !Promise<!Firebase.AuthCallbackData,!Error>
     |
     !goog.Promise<!Firebase.AuthCallbackData,!Error>
    } A promise which resolves to the authData, or is rejected with an error.
 */
onfire.utils.firebase.authWithOAuthPopup = function(ref, provider, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authWithOAuthPopup(provider,
            function(/** Firebase.Error */err, /** Firebase.AuthCallbackData */authData){
                !err ? resolve(authData) : reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.authWithOAuthRedirect() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {string} provider
 * @param {!Object=} opt_options
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>} A promise which resolves to the
 *      authData, or is rejected with an error.
 */
onfire.utils.firebase.authWithOAuthRedirect = function(ref, provider, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authWithOAuthRedirect(provider,
            function(/** !Firebase.Error */err){
                reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.authWithOAuthToken() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {string} provider
 * @param {string|!Object} credentials
 * @param {!Object=} opt_options
 * @return
    {
     !Promise<!Firebase.AuthCallbackData,!Error>
     |
     !goog.Promise<!Firebase.AuthCallbackData,!Error>
    } A promise which resolves to the authData, or is rejected with an error.
 */
onfire.utils.firebase.authWithOAuthToken = function(ref, provider, credentials, opt_options) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.authWithOAuthToken(provider, credentials,
            function(/** Firebase.Error */err, /** Firebase.AuthCallbackData */authData){
                !err ? resolve(authData) : reject(err);
            }, opt_options);
    });
};


/**
 * Firebase.createUser() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!Firebase.AuthPasswordCredentials} credentials
 * @return {!Promise<!{uid:string},!Error>|!goog.Promise<!{uid:string},!Error>} A promise which
 *      resolves to a userData object, or is rejected with an error.
 */
onfire.utils.firebase.createUser = function(ref, credentials) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.createUser(credentials,
            function(/** Firebase.Error */err, /** {uid:string} */userData){
                !err ? resolve(userData) : reject(err);
            });
    });
};


/**
 * Firebase.changeEmail() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!{oldEmail:string, password:string, newEmail:string}} credentials
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>} A promise which resolves when the
 *      operation is complete, or is rejected with an error.
 */
onfire.utils.firebase.changeEmail = function(ref, credentials) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.changeEmail(credentials,
            function(/** Firebase.Error */err){
                !err ? resolve() : reject(err);
            });
    });
};


/**
 * Firebase.changePassword() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!{email:string, oldPassword:string, newPassword:string}} credentials
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>} A promise which resolves when the
 *      operation is complete, or is rejected with an error.
 */
onfire.utils.firebase.changePassword = function(ref, credentials) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.changePassword(credentials,
            function(/** Firebase.Error */err){
                !err ? resolve() : reject(err);
            });
    });
};


/**
 * Firebase.removeUser() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!Firebase.AuthPasswordCredentials} credentials
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>} A promise which resolves when the
 *      operation is complete, or is rejected with an error.
 */
onfire.utils.firebase.removeUser = function(ref, credentials) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.removeUser(credentials,
            function(/** Firebase.Error */err){
                !err ? resolve() : reject(err);
            });
    });
};


/**
 * Firebase.resetPassword() wrapped in a promise.
 *
 * @param {!Firebase} ref
 * @param {!{email:string}} credentials
 * @return {!Promise<null,!Error>|!goog.Promise<null,!Error>} A promise which resolves when the
 *      operation is complete, or is rejected with an error.
 */
onfire.utils.firebase.resetPassword = function(ref, credentials) {
    return onfire.utils.promise.newPromise(function(resolve, reject) {
        ref.resetPassword(credentials,
            function(/** Firebase.Error */err){
                !err ? resolve() : reject(err);
            });
    });
};


/**
 * @enum {string}
 */
onfire.utils.firebase.EventType = {
    VALUE: 'value',
    CHILD_ADDED: 'child_added',
    CHILD_CHANGED: 'child_changed',
    CHILD_REMOVED: 'child_removed',
    CHILD_MOVED: 'child_moved'
};


onfire.utils.firebase.TIMESTAMP = onfire.utils.Firebase_.ServerValue.TIMESTAMP;
